package aw;

import java.util.ArrayList;

public class AI2 extends ParentAI{
	
	private ArrayList<String> previousLocations; //holds previous locations in form 1A, read by using charAt
	
	public AI2(Car c){
		super(c);
		previousLocations = new ArrayList<String>();
	}

	@Override
	public void move() {
		// TODO make an AI with following specs
		// The car holds a list of locations of where it has been.
		// It will move a random direction to a space that it hasn't been to yet.
		
		
		// If there is not any valid move, the car wipes the list clean and starts over.
		if(!super.canMoveEast && !super.canMoveNorth && !super.canMoveSouth && !super.canMoveWest){
			previousLocations.removeAll(null);
			generateNextRandomMove(true, true, true, true);
		}
		
		
	}
	
	private void generateNextRandomMove(boolean yesN, boolean yesE, boolean yesS, boolean yesW){
		double randomDecimal = Math.random();
		if(yesN && yesE && yesS && yesW){ //if all 4 directions are valid
			if(randomDecimal < .25){ //Move north
				moveNorth();
			}
			else if(randomDecimal < .5){ //Move east
				moveEast();
			}
			else if(randomDecimal < .75){ //Move South
				moveSouth();
			}
			else{ //move West
				moveWest();
			}
		}
		//TODO cover all cases
		
	}
	
	//override these method in order to add the previous moves to the list of previous moves
	//add last move to list of previous moves
	public void moveNorth(){
		super.moveNorth();
		int cX = super.currentX;
		char cY = super.currentY;
		previousLocations.add(new String(String.valueOf(cX) + cY));
	}
	
	public void moveEast(){
		super.moveEast();
		int cX = super.currentX;
		char cY = super.currentY;
		previousLocations.add(new String(String.valueOf(cX) + cY));
		
	}
	
	public void moveSouth(){
		super.moveSouth();
		int cX = super.currentX;
		char cY = super.currentY;
		previousLocations.add(new String(String.valueOf(cX) + cY));
		
	}
	
	public void moveWest(){
		super.moveWest();
		int cX = super.currentX;
		char cY = super.currentY;
		previousLocations.add(new String(String.valueOf(cX) + cY));
		
	}
	
	//finds out where invalid move directions are based on the list of previous moves
	//TODO parse list and seeing if any matches found between 4 possible moves 
	//and then setting canMove booleans from superclass to false
	private void findInvalidMoveDirectionsBasedOnPreviousMoves(){
		
	}

}
